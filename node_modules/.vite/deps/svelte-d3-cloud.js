import {
  ordinal
} from "./chunk-U25LNLHN.js";
import {
  require_d3_cloud
} from "./chunk-MUBW33R7.js";
import {
  select_default
} from "./chunk-QMZUOHOC.js";
import {
  Accent_default,
  Dark2_default,
  Paired_default,
  Pastel1_default,
  Pastel2_default,
  Set1_default,
  Set2_default,
  Set3_default,
  Tableau10_default,
  category10_default,
  src_exports
} from "./chunk-W4L6NLKJ.js";
import "./chunk-2X65D5SP.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  add_location,
  append_styles,
  attr_dev,
  children,
  claim_element,
  createEventDispatcher,
  detach_dev,
  dispatch_dev,
  element,
  init,
  insert_hydration_dev,
  noop,
  onMount,
  safe_not_equal,
  set_style,
  validate_slots
} from "./chunk-K6MJRMI7.js";
import {
  __toESM
} from "./chunk-AC2VUBZ6.js";

// node_modules/svelte-d3-cloud/src/WordCloud.svelte
var import_d3_cloud = __toESM(require_d3_cloud());
var file = "node_modules/svelte-d3-cloud/src/WordCloud.svelte";
function add_css(target) {
  append_styles(target, "svelte-ujvcz1", "div#wordcloud.svelte-ujvcz1{width:fit-content;height:fit-content}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiV29yZENsb3VkLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUF1R0ksR0FBRyxVQUFVLGNBQUMsQ0FBQyxBQUNYLEtBQUssQ0FBRSxXQUFXLENBQ2xCLE1BQU0sQ0FBRSxXQUFXLEFBQ3ZCLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiV29yZENsb3VkLnN2ZWx0ZSJdfQ== */");
}
function create_fragment(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true, style: true, class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "id", "wordcloud");
      set_style(
        div,
        "background-color",
        /*backgroundColor*/
        ctx[0]
      );
      attr_dev(div, "class", "svelte-ujvcz1");
      add_location(div, file, 100, 0, 2674);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*backgroundColor*/
      1) {
        set_style(
          div,
          "background-color",
          /*backgroundColor*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("WordCloud", slots, []);
  const dispatch = createEventDispatcher();
  const color_scheme = {
    schemeCategory10: category10_default,
    schemeAccent: Accent_default,
    schemeDark2: Dark2_default,
    schemePaired: Paired_default,
    schemePastel1: Pastel1_default,
    schemePastel2: Pastel2_default,
    schemeSet1: Set1_default,
    schemeSet2: Set2_default,
    schemeSet3: Set3_default,
    schemeTableau10: Tableau10_default
  };
  let { words = [] } = $$props;
  let { width = 800 } = $$props;
  let { height = 500 } = $$props;
  let { font = "Impact" } = $$props;
  let { maxFontSize = 50 } = $$props;
  let { minRotate = 0 } = $$props;
  let { maxRotate = 0 } = $$props;
  let { scheme = "schemeTableau10" } = $$props;
  let { padding = 10 } = $$props;
  let { backgroundColor = "#fff" } = $$props;
  const maxWordCount = words.reduce((prev, cur) => prev.count < cur.count ? prev.count : cur.count);
  const fill = ordinal(color_scheme[scheme]);
  const onWordClick = (d) => dispatch("click", d);
  const onWordMouserOver = (d) => dispatch("mouseover", d);
  const onWordMouseOut = (d) => dispatch("mouseout", d);
  const onWordMouseMove = (d) => dispatch("mousemove", d);
  const layout = (0, import_d3_cloud.default)().size([width, height]).words(words).padding(padding).rotate(() => ~~(Math.random() * maxRotate) + minRotate).font(font).fontSize((d) => Math.floor(d.count / maxWordCount * maxFontSize)).on("end", draw);
  function draw(words2) {
    select_default("#wordcloud").append("svg").attr("width", layout.size()[0]).attr("height", layout.size()[1]).append("g").attr("transform", "translate(" + layout.size()[0] / 2 + "," + layout.size()[1] / 2 + ")").selectAll("text").data(words2).enter().append("text").style("font-size", (d) => d.size + "px").style("font-family", font).style("fill", (_d, i) => fill(i)).attr("text-anchor", "middle").attr("transform", (d) => "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")").text((d) => d.text).on("click", onWordClick).on("mouseover", onWordMouserOver).on("mouseout", onWordMouseOut).on("mousemove", onWordMouseMove);
  }
  onMount(async () => {
    layout.start();
  });
  const writable_props = [
    "words",
    "width",
    "height",
    "font",
    "maxFontSize",
    "minRotate",
    "maxRotate",
    "scheme",
    "padding",
    "backgroundColor"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<WordCloud> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("words" in $$props2)
      $$invalidate(1, words = $$props2.words);
    if ("width" in $$props2)
      $$invalidate(2, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(3, height = $$props2.height);
    if ("font" in $$props2)
      $$invalidate(4, font = $$props2.font);
    if ("maxFontSize" in $$props2)
      $$invalidate(5, maxFontSize = $$props2.maxFontSize);
    if ("minRotate" in $$props2)
      $$invalidate(6, minRotate = $$props2.minRotate);
    if ("maxRotate" in $$props2)
      $$invalidate(7, maxRotate = $$props2.maxRotate);
    if ("scheme" in $$props2)
      $$invalidate(8, scheme = $$props2.scheme);
    if ("padding" in $$props2)
      $$invalidate(9, padding = $$props2.padding);
    if ("backgroundColor" in $$props2)
      $$invalidate(0, backgroundColor = $$props2.backgroundColor);
  };
  $$self.$capture_state = () => ({
    onMount,
    createEventDispatcher,
    cloud: import_d3_cloud.default,
    select: select_default,
    scaleOrdinal: ordinal,
    CS: src_exports,
    dispatch,
    color_scheme,
    words,
    width,
    height,
    font,
    maxFontSize,
    minRotate,
    maxRotate,
    scheme,
    padding,
    backgroundColor,
    maxWordCount,
    fill,
    onWordClick,
    onWordMouserOver,
    onWordMouseOut,
    onWordMouseMove,
    layout,
    draw
  });
  $$self.$inject_state = ($$props2) => {
    if ("words" in $$props2)
      $$invalidate(1, words = $$props2.words);
    if ("width" in $$props2)
      $$invalidate(2, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(3, height = $$props2.height);
    if ("font" in $$props2)
      $$invalidate(4, font = $$props2.font);
    if ("maxFontSize" in $$props2)
      $$invalidate(5, maxFontSize = $$props2.maxFontSize);
    if ("minRotate" in $$props2)
      $$invalidate(6, minRotate = $$props2.minRotate);
    if ("maxRotate" in $$props2)
      $$invalidate(7, maxRotate = $$props2.maxRotate);
    if ("scheme" in $$props2)
      $$invalidate(8, scheme = $$props2.scheme);
    if ("padding" in $$props2)
      $$invalidate(9, padding = $$props2.padding);
    if ("backgroundColor" in $$props2)
      $$invalidate(0, backgroundColor = $$props2.backgroundColor);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    backgroundColor,
    words,
    width,
    height,
    font,
    maxFontSize,
    minRotate,
    maxRotate,
    scheme,
    padding
  ];
}
var WordCloud = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        words: 1,
        width: 2,
        height: 3,
        font: 4,
        maxFontSize: 5,
        minRotate: 6,
        maxRotate: 7,
        scheme: 8,
        padding: 9,
        backgroundColor: 0
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "WordCloud",
      options,
      id: create_fragment.name
    });
  }
  get words() {
    throw new Error("<WordCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set words(value) {
    throw new Error("<WordCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<WordCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<WordCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<WordCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<WordCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get font() {
    throw new Error("<WordCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set font(value) {
    throw new Error("<WordCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxFontSize() {
    throw new Error("<WordCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxFontSize(value) {
    throw new Error("<WordCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minRotate() {
    throw new Error("<WordCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minRotate(value) {
    throw new Error("<WordCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxRotate() {
    throw new Error("<WordCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxRotate(value) {
    throw new Error("<WordCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scheme() {
    throw new Error("<WordCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scheme(value) {
    throw new Error("<WordCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<WordCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<WordCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backgroundColor() {
    throw new Error("<WordCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backgroundColor(value) {
    throw new Error("<WordCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var WordCloud_default = WordCloud;
export {
  WordCloud_default as default
};
//# sourceMappingURL=svelte-d3-cloud.js.map
